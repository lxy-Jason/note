# 计算属性

在模板表达式非常方便，但它们只适用于简单的操作。

在模板中放入过多的逻辑会使其变得臃肿且难以维护。例如：

```vue
<div id="example">
  {{ message.split('').reverse().join('') }}
</div>
```

此时，模板已不再简单和直观。

你得花一秒钟才能意识到它是以相反的顺序显示信息。

当你想在模板中多次包含反转的消息时，问题会变得更加严重。

这就是为什么对于任何复杂的逻辑，你应该使用计算属性。

## 基本例子

```vue
<div id="example">
  <p>Original message: "{{ message }}"</p>
  <p>Computed reversed message: "{{ reversedMessage }}"</p>
</div>
```

```js
var vm = new Vue({
  el: '#example',
  data: {
    message: 'Hello'
  },
  computed: {
    // a computed getter
    reversedMessage: function () {
      // `this` 指向vm实例
      return this.message.split('').reverse().join('')
    }
  }
})
```

在这里，我们声明了一个计算属性reversedMessage。我们提供的函数将被用作属性vm.reversedMessage的getter函数：

```js
console.log(vm.reversedMessage) // => 'olleH'
vm.message = 'Goodbye'
console.log(vm.reversedMessage) // => 'eybdooG'
```

你可以打开控制台自己玩一下示例。vm.reversedMessage的值始终取决于vm.message的值。

你可以像普通属性一样在模板中绑定到计算属性。

Vue知道vm.reversedMessage依赖于vm.message，因此当vm.message发生变化时，它会更新所有依赖于vm.reversedMessage的绑定。

而且最好的部分是，我们以声明方式创建了这种依赖关系：计算的 getter 函数没有副作用，这使得测试和理解变得更加容易。