### 鉴权方案

- 纯cookie验证
- session + cookie
- token验证
- JWT

### 纯cookie验证

1. 浏览器首次登录,服务器收到请求后去数据库校验用户名和密码
2. 校验通过后,从数据库查询对应的用户信息
3. 把非重要信息(用户名,邮箱等)通过响应体`set-cookie`存入到浏览器中
4. 浏览器下次请求接口,自动携带`cookie`信息在请求体中,其中包含了用户的信息(如username)
5. 服务器拿到请求体中的cookie,如果包含username等用户信息,则校验通过

#### 重点

cookie可以设置过期时间`expires`以及作用范围`path`

浏览器可以直接修改cookie,在控制台或者应用页(Application)中修改

为了防止js脚本修改cookie,可以设置`httpOnly`的限制,但通过应用页还是可以修改

#### 优缺点

优点: 操作简单

缺点:

- 服务器压力大,因为每次都需要去数据库中校验,查询次数太多
- cookie容易被篡改
- 大小有限制,而且只能存储字符串
- cookie无法跨域

这种方式基本不用了

### session + cookie

1. 前两步一样的,首次登录,服务器去数据库中校验信息,拿到对应的数据
2. 在服务器进程中创建`session`,把用户数据保存起来
3. 设置`set-cookie`,把`sessionId`(一般是userId,因为userId比直接暴露username更安全)返回
4. 浏览器下次请求接口,自动携带cookie,其中有sessionId
5. 服务器拿到Id之后,就可以判断对应哪个用户

#### 重点

1. `session`是服务端存储,这个不是sessionStorage
2. `session`是保存在服务器进程中的,关闭服务器进程,`session`无法获取
3. `session`可以存储任意类型的数据,且大小比`cookie`大得多

#### 优缺点

1. 安全性较高,客户端只能拿到`sessionId`而不是用户数据
2. 减少了数据库查询次数
3. 可以设置`session`的过期时间,不受cookie过期时间影响
4. 存储的数据类型不受限制

缺点:

1. 占用服务器资源了,用户量很大的时候,内容消耗不起
2. 正常情况下,session在不同的服务器中无法共享,比如同一家公司的两个网站,当登录一个之后要求另外一个能够直接登录(单点登录),这就要求每个进程都能共享session(通过session持久化实现这个)

#### session持久化

感觉是后端的内容了

- Redis 实现

未完待续

https://juejin.cn/post/7067531231918817310



