垃圾回收(GC)就是将那些不再继续使用的变量所对应的内存空间释放掉

### 垃圾回收的两种方式

#### 标记清除

首先一开始的时候从根节点出发,遍历所有对象,打上标记

等到垃圾回收时,再一次遍历所有对象,将能够遍历到的对象的标签给删除掉

此时还有标记的对象就是已经无法访问到的,也就是再也用不到的对象

垃圾回收就是将这些有标记的对象给清除掉

### 引用计数

就是跟踪记录每个值被引用的次数,每多一次引用计数加一,断开一次引用计数减一

当计数为0就表示无法访问到这个变量了

垃圾回收的时候就可以将这些计数为0的清除掉

### 引用计数存在的问题

**循环引用**

当对象A引用对象B,对象B引用对象A时

即使没有两个对象都没有其他的引用,但是因为他们直接相互引用,计数不为0

所以无法回收

### 垃圾回收存在的问题

一个是当进行垃圾回收时,会停止js的执行

如果垃圾很多,那么暂停的时长太长就会造成页面卡顿

所以什么时候进行垃圾回收是一个重要的问题

第二个是垃圾回收只是将不使用的内存清除掉,但清理出来的内存是一小块一小块的内存空间(内存碎片)

如果内存空间都是这种碎片状,那么可能存在突然来一个大对象放不下的情况,这时候会直接触发一次垃圾回收

这也是一个问题

### Chrome的垃圾回收策略

#### 分代回收(Generation GC)

js中绝大多数对象的生命周期是很短的(比如:函数中的局部变量),但是有少部分生命周期很长(比如:window)

这部分生命周期很长的对象,就不需要频繁的进行垃圾回收

V8将堆内存分为两类`新生代`和`老生代`,新生代中存在的是生命周期短的对象,老生代存在生命周期长的对象

新生代通常只有1~8M的容量,而老生代就大的多

两个区域分别使用不同的垃圾回收器

- 副垃圾回收器 - Scavenge: 负责新生代的垃圾回收
- 主垃圾回收器 - Mark-Sweep & Mark-Compact: 负责老生代的垃圾回收

#### 新生代垃圾回收器

声明变量分配内存,首先放入新生代中,因为大部分变量声明周期不长

在新生代中垃圾回收算法是将新生代分成两部分,一部分放置对象(称为对象区域),一部分空着(称为空闲区域)

当放置对象的区域快放满的时候,进行一次垃圾回收,用的也是标记清除

将依然存活的对象放入另一部分的空闲区域,同时将其有序的排列起来

这里就消灭了内存碎片

然后将对象区域和空闲区域身份互换

这样新生代区域就解决了垃圾过多,导致清理耗时长的问题;也解决了内存碎片的问题

### 老生代垃圾回收器

因为一开始分配内存都是放在新生代中,为了达到生命周期长的对象少进行垃圾回收,从而提高垃圾回收效率的目的

当新生代中的对象经过两次垃圾回收还存在的时候,就会被移入老生代

老生代也是通过标记清除将不活跃对象清除掉,但这里没有进行复制排序的操作,是直接将不活跃对象清理掉

这样就产生了内存碎片

这里用的是Mark-Compact(标记整理),在标记清除的基础上增加一个活动对象整理的阶段,将所有活跃对象向一段移动

移动完成后直接清除边界外的内存

### 增量标记-Incremental marking

即使是做到上面那种程度可能还不够,当堆的大小达到一定的阈值后会启动增量标记

增量标记是将原本一次性标记所有对象改成一个个任务,放在js应用逻辑之间执行

### 惰性清理-Lazy sweeping

配合增量标记使用,增量标记只是单纯的标记,真正清除还得惰性清除来做

和增量标记一样,放在js逻辑执行的间隔之间

### 增量标记的问题

因为在js逻辑之间进行标记

那么就有可能某个对象,原本应该被标记但因为还没有执行到对应的逻辑

导致没有标记而被清除

这里用了`写屏障`技术来记录这些引用关系上的变化

不懂这个写屏障

### 并发-Concurrent

用辅助线程来进行垃圾回收,这样垃圾回收可以和主线程同时进行,不过还是会有短暂的停止主线程去做一些特殊的操作

同样存在引用关系改变导致的问题,同样要用到写屏障技术

这个用在老生代标记清除中

### 并行- Parallel

主线程和辅助线程同时进行GC,这样可以通过辅助线程分担主线程工作,使得耗时减少

这个被用在新生代整理排序时







