### v-model的原理

是value属性加input事件的语法糖

具体相当于:

- v-bind:value绑定一个变量msg
- @input事件调用时修改msg

### 为什么要proxy中使用reflect

- 只要`Proxy`对象具有的代理方法，`Reflect`对象全部具有，以静态方法的形式存在。这些方法能够执行默认行为，无论`Proxy`怎么修改默认行为，总是可以通过`Reflect`对应的方法获取默认行为。
- 修改某些`Object`方法的返回结果，让其变得更合理。比如，`Object.defineProperty(obj, name, desc)`在无法定义属性时，会抛出一个**错误**，而`Reflect.defineProperty(obj, name, desc)`则会返回`false`。
- 让`Object`操作都变成函数行为。某些`Object`操作是命令式，比如`name in obj`和`delete obj[name]`，而`Reflect.has(obj, name)`和`Reflect.deleteProperty(obj, name)`让它们变成了函数行为。

**`Reflect`对象的操作和`Proxy`对象的操作一一对应，在`Proxy`的拦截操作中，可以直接利用`Reflect`对象直接获取`Proxy`的默认值。**

---

### 计算属性

计算属性的返回值应该被视为**只读**的，并且永远不应该被更改

在计算属性中使用 `reverse()` 和 `sort()` 的时候务必小心！这两个方法将变更原始数组，计算函数中不应该这么做。请在调用这些方法之前创建一个原数组的副本

---

### class

```js	
<div :class="{ active: isActive }"></div>
```

上面的语法表示 `active` 是否存在取决于数据属性 `isActive` 的[真假值](https://developer.mozilla.org/en-US/docs/Glossary/Truthy)。

给组件添加class会添加到根元素上

多个根元素则需要指定哪个根元素来接收class,通过组件的`$attrs`属性实现

---

### 自动前缀

当你在 `:style` 中使用了需要[浏览器特殊前缀](https://developer.mozilla.org/en-US/docs/Glossary/Vendor_Prefix)的 CSS 属性时，Vue 会自动为他们加上相应的前缀。Vue 是在运行时检查该属性是否支持在当前浏览器中使用。如果浏览器不支持某个属性，那么将测试加上各个浏览器特殊前缀，以找到哪一个是被支持的。

---

### 样式多值

你可以对**一个样式属性提供多个 (不同前缀的) 值**，举例来说：

```js
<div :style="{ display: ['-webkit-box', '-ms-flexbox', 'flex'] }"></div>
```

数组仅会渲染浏览器支持的**最后一个值**。在这个示例中，在支持不需要特别前缀的浏览器中都会渲染为 `display: flex`

### 显示与隐藏多个元素

在一个 `<template>` 元素上使用 `v-if`

`v-show` 不支持在 `<template>` 元素上使用，也不能和 `v-else` 搭配使用。

---

`v-if` 有更高的切换开销，而 `v-show` 有更高的初始渲染开销。因此，如果需要频繁切换，则使用 `v-show` 较好；如果在运行时绑定条件很少改变，则 `v-if` 会更合适。

---

### 不应该同时使用`v-for`和`v-if`

当它们同时存在于一个节点上时，`v-if` 比 `v-for` 的优先级更高。这意味着 `v-if` 的条件将无法访问到 `v-for` 作用域内定义的变量别名

```js
<!--
 这会抛出一个错误，因为属性 todo 此时
 没有在该实例上定义
-->
<li v-for="todo in todos" v-if="!todo.isComplete">
  {{ todo.name }}
</li>
```



---

可以在定义 `v-for` 的变量别名时使用解构，和解构函数参数类似

```js
<li v-for="{ message } in items">
  {{ message }}
</li>

<!-- 有 index 索引时 -->
<li v-for="({ message }, index) in items">
  {{ message }} {{ index }}
</li>
```

可以使用 `of` 作为分隔符来替代 `in`，这更接近 JavaScript 的迭代器语法

```js
<div v-for="item of items"></div>
```

---

可以使用 `v-for` 来遍历一个对象的所有属性。遍历的顺序会基于对该对象调用 `Object.keys()` 的返回值来决定。

可以通过提供第二个参数表示属性名 (例如 **key**),第三个参数表示位置**索引**：

**这里注意第一个参数拿到的是对象属性的值,只是顺序是通过keys()决定**

```js
<li v-for="(value, key, index) in myObject">
  {{ index }}. {{ key }}: {{ value }}
</li>
```

---

`v-for` 可以直接接受一个整数值

```js
<span v-for="n in 10">{{ n }}</span>
```

**注意:此处 `n` 的初值是从 `1` 开始而非 `0`**

---

不要用对象作为 `v-for` 的 key

### 组件上使用 `v-for`

和在一般的元素上使用没有区别,但是要传递props

```js
<MyComponent
  v-for="(item, index) in items"
  :item="item"
  :index="index"
  :key="item.id"
/>
```

### 在内联事件处理器中访问事件参数

需要在内联事件处理器中访问**原生 DOM 事件**。你可以向该处理器方法传入一个特殊的 `$event` 变量，或者使用内联箭头函数

```js
<!-- 使用特殊的 $event 变量 -->
<button @click="warn('Form cannot be submitted yet.', $event)">
  Submit
</button>

<!-- 使用内联箭头函数 -->
<button @click="(event) => warn('Form cannot be submitted yet.', event)">
  Submit
</button>
```





