### 是什么

官方说法:

`nextTick()` 可以在状态改变后立即使用，以等待 DOM 更新完成。可以传递一个回调函数作为参数，或者 await 返回的 Promise。

在下一次DOM更新之后传入的回调函数将会被执行

简单的说:

通过`nextTick`执行回调,回调函数可以获取到下一次页面更新之后的数据

### 用法

传递一个回调函数作为参数，或者 await 返回的 Promise

### 用途

- DOM更新之后执行延迟回调
- Vue内部使用,把DOM渲染这个操作放入到callbacks中

vue中更改响应式数据,dom的更新并不是同步生效的,vue内部实现是使用一个队列进行缓存,等**同一事件循环**中的所有数据变化完成之后，再统一进行视图更新。如果同一个watcher被多次触发,队列中只保存一次,可以去除重复的操作

避免不必要的计算和DOM操作

这样是为了节约性能,当组件发生多次状态改变时,仅执行一次更新

### 原理

本质上是注册异步任务来对任务进行处理,

### 异步更新实现

通过**异步api**调用`flushCallbacks`函数

在此函数中可以依次执行之前队列中保存的回调函数,完成更新

### 异步api选择

timerFunc函数定义了使用哪种方法执行延迟回调函数

这里采用优雅降级的方式选择异步方法

首先是判断是否原生支持promise(ie不兼容)

不支持就使用MutationObserver(html5新增)

还不行就使用setImmediate

最后是使用setTimeout

### nextTick 可能无法完全保证在视图更新之后执行的情况

1. 在同一个 tick 中多次修改数据：如果在同一个 tick 中多次修改数据，那么 Vue.js 只会将最后一次修改的数据进行视图更新，而不是每次修改都更新。此时，nextTick 可能会在最后一次修改数据之后执行，而不是在所有数据修改之后执行。
2. 在组件销毁时调用 nextTick：当组件被销毁时，Vue.js 会将组件的异步任务全部清除，并且不再进行下一轮事件循环。因此，如果在组件销毁时调用 nextTick，那么 nextTick 的回调函数可能不会被执行。
3. 在异步回调中修改数据：如果在异步回调中修改数据，那么 Vue.js 可能会在异步回调执行之前先进行视图更新，此时 nextTick 的回调函数也会在视图更新之前执行。
